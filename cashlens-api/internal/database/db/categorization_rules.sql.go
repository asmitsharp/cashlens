// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categorization_rules.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGlobalRule = `-- name: CreateGlobalRule :one
INSERT INTO global_categorization_rules (keyword, category, priority, match_type, similarity_threshold, is_active)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at
`

type CreateGlobalRuleParams struct {
	Keyword             string         `json:"keyword"`
	Category            string         `json:"category"`
	Priority            pgtype.Int4    `json:"priority"`
	MatchType           pgtype.Text    `json:"match_type"`
	SimilarityThreshold pgtype.Numeric `json:"similarity_threshold"`
	IsActive            pgtype.Bool    `json:"is_active"`
}

func (q *Queries) CreateGlobalRule(ctx context.Context, arg CreateGlobalRuleParams) (GlobalCategorizationRule, error) {
	row := q.db.QueryRow(ctx, createGlobalRule,
		arg.Keyword,
		arg.Category,
		arg.Priority,
		arg.MatchType,
		arg.SimilarityThreshold,
		arg.IsActive,
	)
	var i GlobalCategorizationRule
	err := row.Scan(
		&i.ID,
		&i.Keyword,
		&i.Category,
		&i.Priority,
		&i.MatchType,
		&i.SimilarityThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserRule = `-- name: CreateUserRule :one
INSERT INTO user_categorization_rules (user_id, keyword, category, priority, match_type, similarity_threshold, is_active)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at
`

type CreateUserRuleParams struct {
	UserID              pgtype.UUID    `json:"user_id"`
	Keyword             string         `json:"keyword"`
	Category            string         `json:"category"`
	Priority            pgtype.Int4    `json:"priority"`
	MatchType           pgtype.Text    `json:"match_type"`
	SimilarityThreshold pgtype.Numeric `json:"similarity_threshold"`
	IsActive            pgtype.Bool    `json:"is_active"`
}

func (q *Queries) CreateUserRule(ctx context.Context, arg CreateUserRuleParams) (UserCategorizationRule, error) {
	row := q.db.QueryRow(ctx, createUserRule,
		arg.UserID,
		arg.Keyword,
		arg.Category,
		arg.Priority,
		arg.MatchType,
		arg.SimilarityThreshold,
		arg.IsActive,
	)
	var i UserCategorizationRule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Keyword,
		&i.Category,
		&i.Priority,
		&i.MatchType,
		&i.SimilarityThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateGlobalRule = `-- name: DeactivateGlobalRule :exec
UPDATE global_categorization_rules
SET is_active = FALSE, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateGlobalRule(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateGlobalRule, id)
	return err
}

const deactivateUserRule = `-- name: DeactivateUserRule :exec
UPDATE user_categorization_rules
SET is_active = FALSE, updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type DeactivateUserRuleParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeactivateUserRule(ctx context.Context, arg DeactivateUserRuleParams) error {
	_, err := q.db.Exec(ctx, deactivateUserRule, arg.ID, arg.UserID)
	return err
}

const deleteGlobalRule = `-- name: DeleteGlobalRule :exec
DELETE FROM global_categorization_rules
WHERE id = $1
`

func (q *Queries) DeleteGlobalRule(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteGlobalRule, id)
	return err
}

const deleteUserRule = `-- name: DeleteUserRule :exec
DELETE FROM user_categorization_rules
WHERE id = $1 AND user_id = $2
`

type DeleteUserRuleParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteUserRule(ctx context.Context, arg DeleteUserRuleParams) error {
	_, err := q.db.Exec(ctx, deleteUserRule, arg.ID, arg.UserID)
	return err
}

const getAllGlobalRules = `-- name: GetAllGlobalRules :many
SELECT id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at FROM global_categorization_rules
WHERE is_active = TRUE
ORDER BY priority DESC, keyword ASC
`

func (q *Queries) GetAllGlobalRules(ctx context.Context) ([]GlobalCategorizationRule, error) {
	rows, err := q.db.Query(ctx, getAllGlobalRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GlobalCategorizationRule{}
	for rows.Next() {
		var i GlobalCategorizationRule
		if err := rows.Scan(
			&i.ID,
			&i.Keyword,
			&i.Category,
			&i.Priority,
			&i.MatchType,
			&i.SimilarityThreshold,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRulesForUser = `-- name: GetAllRulesForUser :many
SELECT
    u.id,
    u.keyword,
    u.category,
    u.priority,
    'user' as rule_type
FROM user_categorization_rules u
WHERE u.user_id = $1 AND u.is_active = TRUE

UNION ALL

SELECT
    g.id,
    g.keyword,
    g.category,
    g.priority,
    'global' as rule_type
FROM global_categorization_rules g
WHERE g.is_active = TRUE
AND g.keyword NOT IN (
    SELECT u2.keyword FROM user_categorization_rules u2
    WHERE u2.user_id = $1 AND u2.is_active = TRUE
)

ORDER BY priority DESC, keyword ASC
`

type GetAllRulesForUserRow struct {
	ID       pgtype.UUID `json:"id"`
	Keyword  string      `json:"keyword"`
	Category string      `json:"category"`
	Priority pgtype.Int4 `json:"priority"`
	RuleType string      `json:"rule_type"`
}

// Get combined list of global and user rules, user rules take precedence
func (q *Queries) GetAllRulesForUser(ctx context.Context, userID pgtype.UUID) ([]GetAllRulesForUserRow, error) {
	rows, err := q.db.Query(ctx, getAllRulesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllRulesForUserRow{}
	for rows.Next() {
		var i GetAllRulesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Keyword,
			&i.Category,
			&i.Priority,
			&i.RuleType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesWithRuleCount = `-- name: GetCategoriesWithRuleCount :many
SELECT
    category,
    COUNT(*) as rule_count
FROM (
    SELECT category FROM global_categorization_rules WHERE is_active = TRUE
    UNION ALL
    SELECT category FROM user_categorization_rules WHERE user_id = $1 AND is_active = TRUE
) AS all_rules
GROUP BY category
ORDER BY rule_count DESC
`

type GetCategoriesWithRuleCountRow struct {
	Category  string `json:"category"`
	RuleCount int64  `json:"rule_count"`
}

func (q *Queries) GetCategoriesWithRuleCount(ctx context.Context, userID pgtype.UUID) ([]GetCategoriesWithRuleCountRow, error) {
	rows, err := q.db.Query(ctx, getCategoriesWithRuleCount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoriesWithRuleCountRow{}
	for rows.Next() {
		var i GetCategoriesWithRuleCountRow
		if err := rows.Scan(&i.Category, &i.RuleCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalRuleByKeyword = `-- name: GetGlobalRuleByKeyword :one
SELECT id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at FROM global_categorization_rules
WHERE keyword = $1 AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetGlobalRuleByKeyword(ctx context.Context, keyword string) (GlobalCategorizationRule, error) {
	row := q.db.QueryRow(ctx, getGlobalRuleByKeyword, keyword)
	var i GlobalCategorizationRule
	err := row.Scan(
		&i.ID,
		&i.Keyword,
		&i.Category,
		&i.Priority,
		&i.MatchType,
		&i.SimilarityThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRuleStats = `-- name: GetRuleStats :one
SELECT
    (SELECT COUNT(*) FROM global_categorization_rules g WHERE g.is_active = TRUE) as global_rules_count,
    (SELECT COUNT(*) FROM user_categorization_rules u WHERE u.user_id = $1 AND u.is_active = TRUE) as user_rules_count,
    (SELECT COUNT(DISTINCT g2.category) FROM global_categorization_rules g2 WHERE g2.is_active = TRUE) as global_categories_count,
    (SELECT COUNT(DISTINCT u2.category) FROM user_categorization_rules u2 WHERE u2.user_id = $1 AND u2.is_active = TRUE) as user_categories_count
`

type GetRuleStatsRow struct {
	GlobalRulesCount      int64 `json:"global_rules_count"`
	UserRulesCount        int64 `json:"user_rules_count"`
	GlobalCategoriesCount int64 `json:"global_categories_count"`
	UserCategoriesCount   int64 `json:"user_categories_count"`
}

func (q *Queries) GetRuleStats(ctx context.Context, userID pgtype.UUID) (GetRuleStatsRow, error) {
	row := q.db.QueryRow(ctx, getRuleStats, userID)
	var i GetRuleStatsRow
	err := row.Scan(
		&i.GlobalRulesCount,
		&i.UserRulesCount,
		&i.GlobalCategoriesCount,
		&i.UserCategoriesCount,
	)
	return i, err
}

const getUserRuleByKeyword = `-- name: GetUserRuleByKeyword :one
SELECT id, user_id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at FROM user_categorization_rules
WHERE user_id = $1 AND keyword = $2 AND is_active = TRUE
LIMIT 1
`

type GetUserRuleByKeywordParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Keyword string      `json:"keyword"`
}

func (q *Queries) GetUserRuleByKeyword(ctx context.Context, arg GetUserRuleByKeywordParams) (UserCategorizationRule, error) {
	row := q.db.QueryRow(ctx, getUserRuleByKeyword, arg.UserID, arg.Keyword)
	var i UserCategorizationRule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Keyword,
		&i.Category,
		&i.Priority,
		&i.MatchType,
		&i.SimilarityThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRules = `-- name: GetUserRules :many
SELECT id, user_id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at FROM user_categorization_rules
WHERE user_id = $1 AND is_active = TRUE
ORDER BY priority DESC, keyword ASC
`

func (q *Queries) GetUserRules(ctx context.Context, userID pgtype.UUID) ([]UserCategorizationRule, error) {
	rows, err := q.db.Query(ctx, getUserRules, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserCategorizationRule{}
	for rows.Next() {
		var i UserCategorizationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Keyword,
			&i.Category,
			&i.Priority,
			&i.MatchType,
			&i.SimilarityThreshold,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRulesByKeyword = `-- name: SearchRulesByKeyword :many
SELECT id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at FROM global_categorization_rules
WHERE keyword ILIKE '%' || $1 || '%' AND is_active = TRUE
ORDER BY priority DESC, keyword ASC
LIMIT $2
`

type SearchRulesByKeywordParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) SearchRulesByKeyword(ctx context.Context, arg SearchRulesByKeywordParams) ([]GlobalCategorizationRule, error) {
	rows, err := q.db.Query(ctx, searchRulesByKeyword, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GlobalCategorizationRule{}
	for rows.Next() {
		var i GlobalCategorizationRule
		if err := rows.Scan(
			&i.ID,
			&i.Keyword,
			&i.Category,
			&i.Priority,
			&i.MatchType,
			&i.SimilarityThreshold,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUserRulesByKeyword = `-- name: SearchUserRulesByKeyword :many
SELECT id, user_id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at FROM user_categorization_rules
WHERE user_id = $1 AND keyword ILIKE '%' || $2 || '%' AND is_active = TRUE
ORDER BY priority DESC, keyword ASC
LIMIT $3
`

type SearchUserRulesByKeywordParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) SearchUserRulesByKeyword(ctx context.Context, arg SearchUserRulesByKeywordParams) ([]UserCategorizationRule, error) {
	rows, err := q.db.Query(ctx, searchUserRulesByKeyword, arg.UserID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserCategorizationRule{}
	for rows.Next() {
		var i UserCategorizationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Keyword,
			&i.Category,
			&i.Priority,
			&i.MatchType,
			&i.SimilarityThreshold,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGlobalRule = `-- name: UpdateGlobalRule :one
UPDATE global_categorization_rules
SET category = $2, priority = $3, match_type = $4, similarity_threshold = $5, is_active = $6, updated_at = NOW()
WHERE id = $1
RETURNING id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at
`

type UpdateGlobalRuleParams struct {
	ID                  pgtype.UUID    `json:"id"`
	Category            string         `json:"category"`
	Priority            pgtype.Int4    `json:"priority"`
	MatchType           pgtype.Text    `json:"match_type"`
	SimilarityThreshold pgtype.Numeric `json:"similarity_threshold"`
	IsActive            pgtype.Bool    `json:"is_active"`
}

func (q *Queries) UpdateGlobalRule(ctx context.Context, arg UpdateGlobalRuleParams) (GlobalCategorizationRule, error) {
	row := q.db.QueryRow(ctx, updateGlobalRule,
		arg.ID,
		arg.Category,
		arg.Priority,
		arg.MatchType,
		arg.SimilarityThreshold,
		arg.IsActive,
	)
	var i GlobalCategorizationRule
	err := row.Scan(
		&i.ID,
		&i.Keyword,
		&i.Category,
		&i.Priority,
		&i.MatchType,
		&i.SimilarityThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserRule = `-- name: UpdateUserRule :one
UPDATE user_categorization_rules
SET category = $2, priority = $3, match_type = $4, similarity_threshold = $5, is_active = $6, updated_at = NOW()
WHERE id = $1 AND user_id = $7
RETURNING id, user_id, keyword, category, priority, match_type, similarity_threshold, is_active, created_at, updated_at
`

type UpdateUserRuleParams struct {
	ID                  pgtype.UUID    `json:"id"`
	Category            string         `json:"category"`
	Priority            pgtype.Int4    `json:"priority"`
	MatchType           pgtype.Text    `json:"match_type"`
	SimilarityThreshold pgtype.Numeric `json:"similarity_threshold"`
	IsActive            pgtype.Bool    `json:"is_active"`
	UserID              pgtype.UUID    `json:"user_id"`
}

func (q *Queries) UpdateUserRule(ctx context.Context, arg UpdateUserRuleParams) (UserCategorizationRule, error) {
	row := q.db.QueryRow(ctx, updateUserRule,
		arg.ID,
		arg.Category,
		arg.Priority,
		arg.MatchType,
		arg.SimilarityThreshold,
		arg.IsActive,
		arg.UserID,
	)
	var i UserCategorizationRule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Keyword,
		&i.Category,
		&i.Priority,
		&i.MatchType,
		&i.SimilarityThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
