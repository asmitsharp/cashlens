// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: summary.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCashFlowTrend = `-- name: GetCashFlowTrend :many
SELECT
    DATE_TRUNC($4::text, txn_date::timestamp)::timestamp AS period,
    COALESCE(SUM(CASE WHEN txn_type = 'credit' THEN amount ELSE 0 END), 0) AS inflow,
    COALESCE(SUM(CASE WHEN txn_type = 'debit' THEN amount ELSE 0 END), 0) AS outflow,
    COALESCE(SUM(CASE WHEN txn_type = 'credit' THEN amount ELSE -amount END), 0) AS net_flow
FROM transactions
WHERE user_id = $1
  AND txn_date BETWEEN $2 AND $3
GROUP BY DATE_TRUNC($4::text, txn_date::timestamp)
ORDER BY period
`

type GetCashFlowTrendParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	TxnDate   pgtype.Date `json:"txn_date"`
	TxnDate_2 pgtype.Date `json:"txn_date_2"`
	DateTrunc string      `json:"date_trunc"`
}

type GetCashFlowTrendRow struct {
	Period  pgtype.Timestamp `json:"period"`
	Inflow  interface{}      `json:"inflow"`
	Outflow interface{}      `json:"outflow"`
	NetFlow interface{}      `json:"net_flow"`
}

func (q *Queries) GetCashFlowTrend(ctx context.Context, arg GetCashFlowTrendParams) ([]GetCashFlowTrendRow, error) {
	rows, err := q.db.Query(ctx, getCashFlowTrend,
		arg.UserID,
		arg.TxnDate,
		arg.TxnDate_2,
		arg.DateTrunc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCashFlowTrendRow{}
	for rows.Next() {
		var i GetCashFlowTrendRow
		if err := rows.Scan(
			&i.Period,
			&i.Inflow,
			&i.Outflow,
			&i.NetFlow,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKPIs = `-- name: GetKPIs :one
SELECT
    COALESCE(SUM(CASE WHEN txn_type = 'credit' THEN amount ELSE 0 END), 0) AS total_inflow,
    COALESCE(SUM(CASE WHEN txn_type = 'debit' THEN amount ELSE 0 END), 0) AS total_outflow,
    COALESCE(SUM(CASE WHEN txn_type = 'credit' THEN amount ELSE -amount END), 0) AS net_cash_flow,
    COUNT(*) AS transaction_count
FROM transactions
WHERE user_id = $1
  AND txn_date BETWEEN $2 AND $3
`

type GetKPIsParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	TxnDate   pgtype.Date `json:"txn_date"`
	TxnDate_2 pgtype.Date `json:"txn_date_2"`
}

type GetKPIsRow struct {
	TotalInflow      interface{} `json:"total_inflow"`
	TotalOutflow     interface{} `json:"total_outflow"`
	NetCashFlow      interface{} `json:"net_cash_flow"`
	TransactionCount int64       `json:"transaction_count"`
}

func (q *Queries) GetKPIs(ctx context.Context, arg GetKPIsParams) (GetKPIsRow, error) {
	row := q.db.QueryRow(ctx, getKPIs, arg.UserID, arg.TxnDate, arg.TxnDate_2)
	var i GetKPIsRow
	err := row.Scan(
		&i.TotalInflow,
		&i.TotalOutflow,
		&i.NetCashFlow,
		&i.TransactionCount,
	)
	return i, err
}

const getNetFlowTrend = `-- name: GetNetFlowTrend :many
SELECT
    DATE_TRUNC($4::text, txn_date::timestamp)::timestamp AS period,
    COALESCE(SUM(CASE WHEN txn_type = 'credit' THEN amount ELSE -amount END), 0) AS net_flow
FROM transactions
WHERE user_id = $1
  AND txn_date BETWEEN $2 AND $3
GROUP BY DATE_TRUNC($4::text, txn_date::timestamp)
ORDER BY period
`

type GetNetFlowTrendParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	TxnDate   pgtype.Date `json:"txn_date"`
	TxnDate_2 pgtype.Date `json:"txn_date_2"`
	DateTrunc string      `json:"date_trunc"`
}

type GetNetFlowTrendRow struct {
	Period  pgtype.Timestamp `json:"period"`
	NetFlow interface{}      `json:"net_flow"`
}

func (q *Queries) GetNetFlowTrend(ctx context.Context, arg GetNetFlowTrendParams) ([]GetNetFlowTrendRow, error) {
	rows, err := q.db.Query(ctx, getNetFlowTrend,
		arg.UserID,
		arg.TxnDate,
		arg.TxnDate_2,
		arg.DateTrunc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNetFlowTrendRow{}
	for rows.Next() {
		var i GetNetFlowTrendRow
		if err := rows.Scan(&i.Period, &i.NetFlow); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
